# Strukt Repo Audit
_Generated: 2025-10-29T18:30:14.360513Z_
## Detected Root`/mnt/data/strukt_repo/Strukt copy`
## Tree (truncated)```
.cursorrules
.editorconfig
.gitignore
.todo
AGENTS.md
PHASE_3_COMPLETE.txt
README.md
README_PHASE_3_COMPLETE.md
docker-compose.yml
package-lock.json
package.json
test-all-endpoints.sh
test-api-connection.js
test_results.txt
.cursor/rules/ai-generation-pipeline.mdc
.cursor/rules/domain-models.mdc
.cursor/rules/domain-ring-system.mdc
.cursor/rules/graph-algorithms.mdc
.giga/specifications.json
.giga/rules/ai-generation-pipeline.mdc
.giga/rules/domain-models.mdc
.giga/rules/domain-ring-system.mdc
.giga/rules/graph-algorithms.mdc
server/.env
server/.env.example
server/.gitignore
server/Dockerfile
server/package-lock.json
server/package.json
server/test-server.js
server/tsconfig.json
server/src/index.ts
server/src/middleware/authOptional.ts
server/src/config/env.ts
server/src/utils/validation.ts
server/src/models/GenerationHistory.ts
server/src/models/GenerationRequest.ts
server/src/models/PRDTemplate.ts
server/src/models/Workspace.ts
server/src/models/WorkspaceVersion.ts
server/src/scripts/generate-embeddings.ts
server/src/scripts/seed-prd-templates.ts
server/src/db/connection.ts
server/src/data/prd_templates/001_backend_api.json
server/src/data/prd_templates/001_backend_api.md
server/src/data/prd_templates/002_frontend_react.json
server/src/data/prd_templates/002_frontend_react.md
server/src/data/prd_templates/003_saas_mvp.json
server/src/data/prd_templates/003_saas_mvp.md
server/src/data/prd_templates/004_data_pipeline.json
server/src/data/prd_templates/004_data_pipeline.md
server/src/data/prd_templates/005_mobile_app.json
server/src/data/prd_templates/005_mobile_app.md
server/src/data/prd_templates/006_aiml_feature.json
server/src/data/prd_templates/006_aiml_feature.md
server/src/data/prd_templates/007_analytics_dashboard.json
server/src/data/prd_templates/007_analytics_dashboard.md
server/src/data/prd_templates/008_marketplace_platform.json
server/src/data/prd_templates/008_marketplace_platform.md
server/src/data/prd_templates/009_internal_tool.json
server/src/data/prd_templates/009_internal_tool.md
server/src/data/prd_templates/010_general_software.json
server/src/data/prd_templates/010_general_software.md
server/src/routes/ai.ts
server/src/routes/generation.ts
server/src/routes/persistence.ts
server/src/routes/prd.ts
server/src/routes/retry.ts
server/src/routes/workspaces-context.ts
server/src/routes/workspaces.ts
server/src/services/CircuitBreaker.ts
server/src/services/ContextInjector.ts
server/src/services/EmbeddingService.ts
server/src/services/GenerationQueue.ts
server/src/services/GenerationService.ts
server/src/services/PRDRetrievalService.ts
server/src/services/PersistenceService.ts
server/src/services/RetryService.ts
docs/AI_Scaffolding_Step1.md
docs/API_DOCUMENTATION.md
docs/ARCHITECTURE.md
docs/BUILD_CHECKLIST.md
docs/CONNECTION_PREVIEW_AND_EDGE_ALIGNMENT.md
docs/DEPLOYMENT_GUIDE.md
docs/FRAMEWORK_COMPLETE.md
docs/INTEGRATION_ANALYSIS_NEW_UI.md
docs/PHASE_1_APPROVED.md
docs/PHASE_1_COMPLETE.md
docs/PHASE_1_COMPLETION_REPORT.txt
docs/PHASE_1_IMPLEMENTATION.md
docs/PHASE_1_INDEX.md
docs/PHASE_1_LAUNCH.md
docs/PHASE_1_SUMMARY.txt
docs/PHASE_1_TASKS.md
docs/PHASE_1_TEST_PLAN.md
docs/PHASE_2_BUILD_VERIFICATION.md
docs/PHASE_2_COMPLETE.md
docs/PHASE_2_DOCUMENTATION_INDEX.md
docs/PHASE_2_IMPLEMENTATION.md
docs/PHASE_2_LAUNCH.md
docs/PHASE_2_QUICK_START.md
docs/PHASE_2_STATUS_REPORT.txt
docs/PHASE_2_SUMMARY.md
docs/PHASE_2_TEST_PLAN.md
docs/PHASE_3_60_PERCENT.md
docs/PHASE_3_70_PERCENT.md
docs/PHASE_3_85_PERCENT.md
docs/PHASE_3_API_REFERENCE.md
docs/PHASE_3_COMPLETION_REPORT.md
docs/PHASE_3_EXECUTION_GUIDE.md
docs/PHASE_3_INDEX.md
docs/PHASE_3_LAUNCH.md
docs/PHASE_3_MID_POINT_STATUS.md
docs/PHASE_3_PRE_LAUNCH_CHECKLIST.md
docs/PHASE_3_PROGRESS_SNAPSHOT.md
docs/PHASE_3_STATUS_CURRENT.md
docs/PROGRESS.md
docs/PROJECT_OVERVIEW.md
docs/QUICK_REFERENCE.md
docs/SESSION_3_1_TO_3_3_SUMMARY.md
docs/SESSION_COMPLETE_READY_FOR_API_KEY.md
docs/SESSION_COMPLETE_TASK_3_10.md
docs/SESSION_COMPLETE_TASK_3_9.md
docs/SETUP.md
docs/START_HERE.md
docs/TASK_2_1_COMPLETE.md
docs/TASK_2_1_SUMMARY.md
docs/TASK_2_2_COMPLETE.md
docs/TASK_2_3_COMPLETE.md
docs/TASK_2_4_COMPLETE.md
docs/TASK_2_6_COMPLETE.md
docs/TASK_2_7_COMPLETE.md
docs/TASK_2_8_COMPLETE.md
docs/TASK_2_9_COMPLETE.md
docs/TASK_3_10_PLANNING.md
docs/TASK_3_10_TESTING_RESULTS.md
docs/TASK_3_1_COMPLETE.md
docs/TASK_3_2_PROGRESS.md
docs/TASK_3_3_COMPLETE.md
docs/TASK_3_4_COMPLETE.md
docs/TASK_3_5_ACTIVATED.md
docs/TASK_3_5_READY.md
docs/TASK_3_6_COMPLETE.md
docs/TASK_3_6_PLANNING.md
docs/TASK_3_7_COMPLETE.md
docs/TASK_3_7_PLANNING.md
docs/TASK_3_8_COMPLETE.md
docs/TASK_3_8_PLANNING.md
docs/TASK_3_9_COMPLETE.md
docs/TASK_3_9_DONE.txt
docs/TASK_3_9_FINAL_SUMMARY.md
docs/TASK_3_9_PERFORMANCE_TEST.md
docs/TASK_3_9_PLANNING.md
docs/UI_INTEGRATION_QUICK_REF.md
docs/UI_INTEGRATION_SUMMARY.md
client/.env
client/.env.example
client/.gitignore
client/Dockerfile
client/Strukt.code-workspace
client/index.html
client/package-lock.json
client/package.json
client/postcss.config.js
client/tailwind.config.ts
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
client/.vscode/settings.json
client/src/App.css
client/src/App.tsx
client/src/index.css
client/src/main.tsx
client/src/uiVersion.ts
client/src/types/ai.ts
client/src/types/index.ts
client/src/tests/layout/radial.spec.ts
client/src/utils_backup/errorHandler.test.ts
client/src/utils_backup/errorHandler.ts
client/src/utils_backup/performanceMonitor.ts
client/src/utils_backup/workspaceValidator.test.ts
client/src/utils_backup/workspaceValidator.ts
client/src/utils/alignment.ts
client/src/utils/analytics.ts
client/src/utils/autoLayout.ts
client/src/utils/bulkOperations.ts
client/src/utils/collision.ts
client/src/utils/connectionState.ts
client/src/utils/d3Relax.ts
client/src/utils/domainLayout.ts
client/src/utils/edgeRouting.ts
client/src/utils/errorHandler.ts
client/src/utils/export.ts
client/src/utils/graphOps.ts
client/src/utils/history.ts
client/src/utils/import.ts
client/src/utils/measure.ts
client/src/utils/performanceMonitor.ts
client/src/utils/relationships.ts
client/src/utils/search.ts
client/src/utils/snapshots.ts
client/src/utils/templates.ts
client/src/utils/enrich/EnrichmentHistory.ts
client/src/utils/enrich/EnrichmentQuestionBank.ts
client/src/utils/enrich/MockAIGenerator.ts
client/src/styles/globals.css
client/src/components/AIButton.tsx
client/src/components/AIEnrichmentModal.tsx
client/src/components/AISuggestPanel.tsx
client/src/components/AddNodeModal.tsx
client/src/components/AnalyticsModal.tsx
client/src/components/BulkActionsToolbar.tsx
client/src/components/BulkTagEditor.tsx
client/src/components/BulkTypeEditor.tsx
client/src/components/CanvasContextMenu.tsx
client/src/components/CenterNode.tsx
client/src/components/CommandPalette.tsx
client/src/components/ConnectModal.tsx
client/src/components/ConnectSourcesModal.tsx
client/src/components/CreateFirstNode.tsx
client/src/components/CustomConnectionLine.tsx
client/src/components/CustomEdge.tsx
client/src/components/CustomNode.tsx
client/src/components/DetailPanel.tsx
client/src/components/DomainRings.tsx
client/src/components/DragPreviewOverlay.tsx
client/src/components/EdgeContextMenu.tsx
client/src/components/EditableCard.tsx
client/src/components/EmptyState.tsx
client/src/components/ErrorBoundary.tsx
client/src/components/ExportMenu.tsx
client/src/components/FloatingFormatToolbar.tsx
client/src/components/ImportNodeModal.tsx
client/src/components/KeyboardShortcutsDialog.tsx
client/src/components/MinimapPanel.tsx
client/src/components/NodeContextMenu.tsx
client/src/components/NodeHierarchy.tsx
client/src/components/OnboardingOverlay.tsx
client/src/components/RelationshipsPanel.tsx
client/src/components/SaveLoadDialog.tsx
client/src/components/SaveTemplateDialog.tsx
client/src/components/SearchPanel.tsx
client/src/components/SelectByCriteria.tsx
client/src/components/Sidebar.tsx
client/src/components/SnapshotsPanel.tsx
client/src/components/StartWizard.tsx
client/src/components/StatusBar.tsx
client/src/components/SuggestionPanel.tsx
client/src/components/TemplateGallery.tsx
client/src/components/Toolbar.tsx
client/src/components/UserSettingsDialog.tsx
client/src/components/ZoomControls.tsx
client/src/components/ui/accordion.tsx
client/src/components/ui/alert-dialog.tsx
client/src/components/ui/alert.tsx
client/src/components/ui/aspect-ratio.tsx
client/src/components/ui/avatar.tsx
client/src/components/ui/badge.tsx
client/src/components/ui/breadcrumb.tsx
client/src/components/ui/button.tsx
client/src/components/ui/calendar.tsx
client/src/components/ui/card.tsx
client/src/components/ui/carousel.tsx
client/src/components/ui/chart.tsx
client/src/components/ui/checkbox.tsx
client/src/components/ui/collapsible.tsx
client/src/components/ui/command.tsx
client/src/components/ui/context-menu.tsx
client/src/components/ui/dialog.tsx
client/src/components/ui/drawer.tsx
client/src/components/ui/dropdown-menu.tsx
client/src/components/ui/form.tsx
client/src/components/ui/hover-card.tsx
client/src/components/ui/input-otp.tsx
client/src/components/ui/input.tsx
client/src/components/ui/label.tsx
client/src/components/ui/menubar.tsx
client/src/components/ui/navigation-menu.tsx
client/src/components/ui/pagination.tsx
client/src/components/ui/popover.tsx
client/src/components/ui/progress.tsx
client/src/components/ui/radio-group.tsx
client/src/components/ui/resizable.tsx
client/src/components/ui/scroll-area.tsx
client/src/components/ui/select.tsx
client/src/components/ui/separator.tsx
client/src/components/ui/sheet.tsx
client/src/components/ui/sidebar.tsx
client/src/components/ui/skeleton.tsx
client/src/components/ui/slider.tsx
client/src/components/ui/sonner.tsx
client/src/components/ui/switch.tsx
client/src/components/ui/table.tsx
client/src/components/ui/tabs.tsx
client/src/components/ui/textarea.tsx
client/src/components/ui/toggle-group.tsx
client/src/components/ui/toggle.tsx
client/src/components/ui/tooltip.tsx
client/src/components/ui/use-mobile.ts
client/src/components/ui/utils.ts
client/src/components/figma/ImageWithFallback.tsx
client/src/api/client.ts
client/src/fixtures/collision_seed.json
client/src/data/examplePrompts.ts
client/src/pages/Whiteboard.css
client/src/services/aiSuggestions.ts
client/src/store/useWorkspaceStore.ts
```
## Key File Presence- ✅ `client/src/App.tsx`- ❌ `src/App.tsx`- ✅ `client/src/utils/collision.ts`- ❌ `src/utils/collision.ts`- ❌ `client/src/layout/domainLayout.ts`- ❌ `src/layout/domainLayout.ts`- ✅ `client/src/utils/autoLayout.ts`- ❌ `src/utils/autoLayout.ts`- ✅ `client/vite.config.ts`- ❌ `vite.config.ts`- ✅ `client/tsconfig.json`- ❌ `tsconfig.json`- ✅ `client/package.json`- ✅ `package.json`## Package Versions
### Root
```json
{}
```
### Client
```json
{
  "react": "^18.3.1",
  "react-dom": "^18.3.1",
  "@xyflow/react": "*",
  "vite": "^6.3.5",
  "typescript": "^5.3.0"
}
```
## Heuristic Analysis
```json
{
  "ReactFlowTagPresent": false,
  "applyLayoutAndRelaxCalls": 3,
  "handleViewModeChangePresent": false,
  "PinsUsage": true,
  "CenterNodeDraggableFalse": true,
  "resolveCollisionsSignature": true,
  "devOutlineCollisionsPresent": true
}
```
## App.tsx: `client/src/App.tsx`
```tsx
// @ts-nocheck
import { useState, useCallback, useEffect, useRef, useMemo } from "react";
import { ReactFlow, 
  Background,
  BackgroundVariant,
  Controls,
  addEdge,
  useNodesState,
  useEdgesState,
  Connection,
  Edge,
  NodeTypes,
  EdgeTypes,
  Node,
  useReactFlow,
  ReactFlowProvider,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { toast } from "sonner";
import { Toaster } from "./components/ui/sonner";
import { AnimatePresence } from "motion/react";
import { updateEdgesWithOptimalHandles } from "./utils/edgeRouting";
import { applyRadialLayout } from "./utils/autoLayout";
import { applyDomainRadialLayout, calculateNewNodePosition, getDomainForNodeType } from "./utils/domainLayout";
import { devOutlineCollisions, resolveCollisions } from "./utils/collision";
import { captureNodeDimensions as measureNodes } from "@/utils/measure";
import seed from "./fixtures/collision_seed.json";
import { alignNodes, distributeNodes, AlignmentType } from "./utils/alignment";
import { HistoryManager } from "./utils/history";
import { exportToPNG, exportToSVG, exportToMarkdown, downloadMarkdown, exportNodeAsJSON, exportNodeAsMarkdown, copyNodeToClipboard, exportBatchAsJSON, exportBatchAsMarkdown, exportSubgraphAsJSON, exportSubgraphAsMarkdown } from "./utils/export";
import { importNodeFromJSON, importMultipleNodesFromJSON } from "./utils/import";
import { getNodesBounds, getViewportForBounds } from '@xyflow/react';

import { Toolbar } from "./components/Toolbar";
import { Sidebar } from "./components/Sidebar";
import { StatusBar } from "./components/StatusBar";
import { ZoomControls } from "./components/ZoomControls";
import { NodeHierarchy } from "./components/NodeHierarchy";
import { AIButton } from "./components/AIButton";
import { CustomNode, CustomNodeData } from "./components/CustomNode";
import { CenterNode, CenterNodeData } from "./components/CenterNode";
import { StartWizard } from "./components/StartWizard";
import { SuggestionPanel } from "./components/SuggestionPanel";
import type { SuggestedNode } from "./types/ai";
import { EditableCardData } from "./components/EditableCard";
import { CustomEdge } from "./components/CustomEdge";
import { DragPreviewOverlay } from "./components/DragPreviewOverlay";
import { AddNodeModal } from "./components/AddNodeModal";
import { AISuggestPanel } from "./components/AISuggestPanel";
import { SaveLoadDialog } from "./components/SaveLoadDialog";
import { UserSettingsDialog } from "./components/UserSettingsDialog";
import { DetailPanel } from "./components/DetailPanel";
import { ConnectModal } from "./components/ConnectModal";
import { OnboardingOverlay } from "./components/OnboardingOverlay";
import { EmptyState } from "./components/EmptyState";
import { KeyboardShortcutsDialog } from "./components/KeyboardShortcutsDialog";
import { FloatingFormatToolbar } from "./components/FloatingFormatToolbar";
import { CommandPalette } from "./components/CommandPalette";
import { CanvasContextMenu } from "./components/CanvasContextMenu";
import { NodeContextMenu } from "./components/NodeContextMenu";
import { ImportNodeModal } from "./components/ImportNodeModal";
import { AIEnrichmentModal } from "./components/AIEnrichmentModal";
import { SearchPanel } from "./components/SearchPanel";
import { BulkActionsToolbar } from "./components/BulkActionsToolbar";
import { BulkTagEditor } from "./components/BulkTagEditor";
import { BulkTypeEditor } from "./components/BulkTypeEditor";
import { SelectByCriteria } from "./components/SelectByCriteria";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { TemplateGallery } from "./components/TemplateGallery";
import { SaveTemplateDialog } from "./components/SaveTemplateDialog";
import { MinimapPanel } from "./components/MinimapPanel";
import { AnalyticsModal } from "./components/AnalyticsModal";
import { SnapshotsPanel } from "./components/SnapshotsPanel";
import { RelationshipsPanel } from "./components/RelationshipsPanel";
import { CustomConnectionLine } from "./components/CustomConnectionLine";
import { setConnectStart } from "./utils/connectionState";
import { DomainRings } from "./components/DomainRings";
import { EdgeContextMenu } from "./components/EdgeContextMenu";
import { ConnectSourcesModal } from "./components/ConnectSourcesModal";
import { applySuggestions } from "./utils/graphOps";
import { submitFeedback } from "./services/aiSuggestions";
import {
  bulkAddTags,
  bulkRemoveTags,
  bulkReplaceTags,
  bulkChangeType,
  bulkDeleteNodes,
  bulkDuplicateNodes,
  bulkUpdateTodos,
  bulkClearCards,
  selectNodesByCriteria,
  BulkSelectionCriteria,
} from "./utils/bulkOperations";
import { Template } from "./utils/templates";
import { calculateAnalytics, getInsights } from "./utils/analytics";
import { createAutoSnapshot, getSnapshots } from "./utils/snapshots";
import { RelationshipType, setRelationshipType, getRelationshipLabel } from "./utils/relationships";

const nodeTypes: NodeTypes = {
  custom: CustomNode,
  center: CenterNode,
};

const edgeTypes: EdgeTypes = {
  custom: CustomEdge,
};

const LAYOUT_VERSION_KEY = "flowforge-layout-version";
const CURRENT_LAYOUT_VERSION = "radial-v2";

const haveDimensionsChanged = (prev = {}, next = {}) => {
  const prevKeys = Object.keys(prev);
  const nextKeys = Object.keys(next);
  if (prevKeys.length !== nextKeys.length) {
    return true;
  }
  for (const key of nextKeys) {
    const prevValue = prev[key];
    const nextValue = next[key];
    if (!prevValue) {
      return true;
    }
    // 1px tolerance to avoid re-layout due to measurement jitter
    const dw = Math.abs((prevValue.width ?? 0) - (nextValue.width ?? 0));
    const dh = Math.abs((prevValue.height ?? 0) - (nextValue.height ?? 0));
    if (dw > 1 || dh > 1) {
      return true;
    }
  }
  return false;
};

const buildPositionMap = (nodes: Node[]) => {
  const map: Record<string, { x: number; y: number }> = {};
  nodes.forEach((node) => {
    if (!node?.id) return;
    const { x = 0, y = 0 } = node?.position || {};
    map[node.id] = { x: Math.round(x), y: Math.round(y) };
  });
  return map;
};

const didCanonicalPositionsChange = (
  previous: Record<string, { x: number; y: number }> | null | undefined,
  next: Record<string, { x: number; y: number }>
) => {
  if (!previous) return true;
  const prevKeys = Object.keys(previous);
  const nextKeys = Object.keys(next);
  if (prevKeys.length !== nextKeys.length) {
    return true;
  }
  for (const key of nextKeys) {
    const prevPos = previous[key];
    const nextPos = next[key];
    if (!prevPos || prevPos.x !== nextPos.x || prevPos.y !== nextPos.y) {
      return true;
    }
  }
  return false;
};

const DEFAULT_CARD_WIDTH = 280;
const DEFAULT_CARD_HEIGHT = 200;
const MAX_CARD_HEIGHT_CAP = 720;
const DEFAULT_CARD_HEIGHT_CAP = 640;
const CARD_HEIGHT_MARGIN = 48;

const parseDimensionValue = (value: unknown): number | null => {
  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  return null;
};

const getNodeSizeEstimate = (
  node: Node,
  dimensions?: Record<string, { width: number; height: number }>
) => {
  const fromMap = dimensions?.[node.id];
  if (fromMap) {
    const width = parseDimensionValue(fromMap.width) ?? DEFAULT_CARD_WIDTH;
    const height = parseDimensionValue(fromMap.height) ?? DEFAULT_CARD_HEIGHT;
    return {
      width: Math.max(1, Math.round(width)),
      height: Math.max(1, Math.round(height)),
    };
  }

  const width =
    parseDimensionValue((node as any).width) ??
    parseDimensionValue(node.style?.width) ??
    DEFAULT_CARD_WIDTH;
  const height =
    parseDimensionValue((node as any).height) ??
    parseDimensionValue(node.style?.height) ??
    DEFAULT_CARD_HEIGHT;

  return {
    width: Math.max(1, Math.round(width)),
    height: Math.max(1, Math.round(height)),
  };
};

const rangesOverlap = (aStart: number, aEnd: number, bStart: number, bEnd: number) =>
  Math.max(aStart, bStart) <= Math.min(aEnd, bEnd);

const computeNodeHeightCaps = (
  nodes: Node[],
  dimensions?: Record<string, { width: number; height: number }>
): Record<string, number> => {
  const boxes = nodes.map((node) => {
    const { width, height } = getNodeSizeEstimate(node, dimensions);
    const left = node.position?.x ?? 0;
    const top = node.position?.y ?? 0;
    return {
      id: node.id,
      type: node.type,
      left,
      top,
      right: left + width,
      bottom: top + height,
      width,
      height,
    };
  });

  const caps: Record<string, number> = {};

  boxes.forEach((box) => {
    if (box.type !== "custom") {
      return;
    }

    const overlappingBelow = boxes.filter((other) => {
      if (other.id === box.id) return false;
      if (!rangesOverlap(box.left, box.right, other.left, other.right)) return false;
      return other.top >= box.top;
    });

    let limit = MAX_CARD_HEIGHT_CAP;
    overlappingBelow.forEach((other) => {
      limit = Math.min(limit, other.top - box.top - CARD_HEIGHT_MARGIN);
    });

    if (!Number.isFinite(limit)) {
      limit = DEFAULT_CARD_HEIGHT_CAP;
    }

    limit = Math.max(220, Math.min(MAX_CARD_HEIGHT_CAP, limit));
    caps[box.id] = limit;
  });

  return caps;
};

const annotateNodesWithHeightCaps = (
  nodes: Node[],
  dimensions?: Record<string, { width: number; height: number }>
) => {
  if (!nodes || nodes.length === 0) return nodes;
  const capMap = computeNodeHeightCaps(nodes, dimensions);
  return nodes.map((node) => {
    if (node.type !== "custom") return node;
    const cap = capMap[node.id];
    if (!cap || !Number.isFinite(cap)) return node;
    return {
      ...node,
      data: {
        ...(node.data || {}),
        maxNodeHeight: cap,
      },
    };
  });
};

const initialNodes = [
  {
    id: "center",
    type: "center",
    position: { x: 0, y: 0 },
    style: { width: 360, height: 240 },
    draggable: false,
    selectable: false,
    data: {
      label: "Welcome to Strukt",
      description: "This blank canvas is yours. Click the button below to add your first node and start mapping your architecture.",
      icon: "🧭",
      link: "",
      buttonText: "Connect your Git or Wiki",
      secondaryButtonText: "Create your first node",
      // buttonAction will be added dynamically in nodesWithCallbacks
    } as CenterNodeData,
    positionAbsolute: { x: 0, y: 0 },
  },
];

const initialEdges: Edge[] = [];

// Migration function: convert old handle IDs to new format
const migrateEdgeHandles = (edges: Edge[]): Edge[] => {
  const oldToNewHandleMap: Record<string, string> = {
    'top': 'top-target',
    'right': 'right-target',
    'bottom': 'bottom-target',
    'left': 'left-target',
  };

  return edges.map(edge => {
    let updated = { ...edge };
    
    // Migrate targetHandle if it's in old format
    if (edge.targetHandle && oldToNewHandleMap[edge.targetHandle]) {
      updated = { ...updated, targetHandle: oldToNewHandleMap[edge.targetHandle] };
    }
    
    // Migrate sourceHandle if needed (source handles might also be old format)
    if (edge.sourceHandle) {
      const sourceHandleNewFormat = edge.sourceHandle.replace(/^(top|right|bottom|left)$/, (match: string) => `${match}-source`);
      if (sourceHandleNewFormat !== edge.sourceHandle) {
        updated = { ...updated, sourceHandle: sourceHandleNewFormat };
      }
    }
    
    return updated;
  });
};

function FlowCanvas() {
  const [nodes, setNodesInternal, onNodesChangeInternal] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChangeInternal] = useEdgesState(migrateEdgeHandles(initialEdges));
  
  // Safe wrapper for setNodes that validates node structure
  const setNodes = useCallback((updater: any) => {
    setNodesInternal((prevNodes) => {
      const newNodes = typeof updater === 'function' ? updater(prevNodes) : updater;
      // Validate all nodes have required structure
      const validatedNodes = newNodes.map((node: any) => {
        if (!node || !node.id) {
          console.error('Attempted to set invalid node:', node);
          return null;
        }
        if (!node.position || typeof node.position.x !== 'number' || typeof node.position.y !== 'number') {
          console.error('Node with invalid position:', node);
          return {
            ...node,
            position: { x: 0, y: 0 },
          };
        }
        return node;
      }).filter(Boolean); // Remove null nodes
      
      return validatedNodes;
    });
  }, [setNodesInternal]);
  
  const [isSidebarOpen, setIsSidebarOpen] = useState(true);
  const [isAddNodeModalOpen, setIsAddNodeModalOpen] = useState(false);
  const [isConnectModalOpen, setIsConnectModalOpen] = useState(false);
  const [isAISuggestPanelOpen, setIsAISuggestPanelOpen] = useState(false);
  const [isSaveLoadDialogOpen, setIsSaveLoadDialogOpen] = useState(false);
  const [isUserSettingsOpen, setIsUserSettingsOpen] = useState(false);
  const [isDetailPanelOpen, setIsDetailPanelOpen] = useState(false);
  const [selectedCard, setSelectedCard] = useState<{ nodeId: string; card: EditableCardData } | null>(null);
  const [saveLoadMode, setSaveLoadMode] = useState<"save" | "load">("save");
  const [workspaceName, setWorkspaceName] = useState("My Workspace");
  const [isSaved, setIsSaved] = useState(true);
  const [nodeTypeToAdd, setNodeTypeToAdd] = useState<string | undefined>();
  const [edgePosition, setEdgePosition] = useState<{ x: number; y: number } | null>(null);
  const [dragSourceNodeId, setDragSourceNodeId] = useState<string | null>(null);
  const [dragPreview, setDragPreview] = useState<{ 
    start: { x: number; y: number }; 
    end: { x: number; y: number } 
  } | null>(null);
  const [isAutoLayouting, setIsAutoLayouting] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [isPlacingNode, setIsPlacingNode] = useState(false);
  const [isUserDragging, setIsUserDragging] = useState(false);
  const [placingNodeInfo, setPlacingNodeInfo] = useState<{
    nodeId: string;
    startPos: { x: number; y: number };
  } | null>(null);
  const [isWizardOpen, setIsWizardOpen] = useState(false);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [showEmptyState, setShowEmptyState] = useState(false);
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [isKeyboardShortcutsOpen, setIsKeyboardShortcutsOpen] = useState(false);
  const [isEditingText, setIsEditingText] = useState(false);
const [isCommandPaletteOpen, setIsCommandPaletteOpen] = useState(false);
const [canvasContextMenu, setCanvasContextMenu] = useState<{
  isOpen: boolean;
  position: { x: number; y: number };
}>({ isOpen: false, position: { x: 0, y: 0 } });
const [nodeContextMenu, setNodeContextMenu] = useState<{
  isOpen: boolean;
  position: { x: number; y: number };
  nodeId: string | null;
}>({ isOpen: false, position: { x: 0, y: 0 }, nodeId: null });
const [isAIEnrichmentModalOpen, setIsAIEnrichmentModalOpen] = useState(false);
  const [enrichmentNodeId, setEnrichmentNodeId] = useState<string | null>(null);
  const [isImportModalOpen, setIsImportModalOpen] = useState(false);
  const [edgeToReplace, setEdgeToReplace] = useState<{ id: string; targetNodeId?: string } | null>(null);
  const [isSearchPanelOpen, setIsSearchPanelOpen] = useState(false);
  const [isBulkTagEditorOpen, setIsBulkTagEditorOpen] = useState(false);
  const [isBulkTypeEditorOpen, setIsBulkTypeEditorOpen] = useState(false);
  const [isSelectByCriteriaOpen, setIsSelectByCriteriaOpen] = useState(false);
  const [isTemplateGalleryOpen, setIsTemplateGalleryOpen] = useState(false);
  const [isSaveTemplateDialogOpen, setIsSaveTemplateDialogOpen] = useState(false);
  const [isAnalyticsModalOpen, setIsAnalyticsModalOpen] = useState(false);
  const [isSnapshotsPanelOpen, setIsSnapshotsPanelOpen] = useState(false);
  const [isRelationshipsPanelOpen, setIsRelationshipsPanelOpen] = useState(false);
  const [isConnectSourcesOpen, setIsConnectSourcesOpen] = useState(false);
  const [viewMode, setViewMode] = useState<"radial" | "process">("radial");
  const [showDomainRings, setShowDomainRings] = useState(true);
  const [edgeContextMenu, setEdgeContextMenu] = useState<{
    isOpen: boolean;
    position: { x: number; y: number };
    edgeId: string | null;
    relationshipType?: RelationshipType;
  }>({ isOpen: false, position: { x: 0, y: 0 }, edgeId: null });

  useEffect(() => {
    if (!selectedNodeId) return;
    if (!nodes.some((node) => node.id === selectedNodeId)) {
      setSelectedNodeId(null);
    }
  }, [nodes, selectedNodeId]);

  const reactFlowInstance = useReactFlow();
  const historyManager = useRef(new HistoryManager(50));
  const isUndoRedoAction = useRef(false);
  // Track connection lifecycle to decide between edge vs new node
  const connectStartInfoRef = useRef<{ nodeId: string | null; handleId?: string | null } | null>(null);
  const didConnectRef = useRef(false);
  const lastAutoSnapshotTime = useRef<number>(0);
  const autoLayoutOnLoadRef = useRef<boolean>(false);
  const nodeDimensionsRef = useRef<Record<string, { width: number; height: number }>>({});
  const [dimensionVersion, setDimensionVersion] = useState(0);
  const initialCenterFitRef = useRef(false);
  const layoutDebug = useMemo(() => {
    try {
      const params = new URLSearchParams(window.location.search);
      const q = params.get('layoutDebug') === '1';
      const env = (import.meta as any)?.env?.VITE_LAYOUT_DEBUG === 'on';
      return q || env;
    } catch {
      return false;
    }
  }, []);

  // Optional d3-force relaxer behind VITE_FEATURE_D3_RELAX (default off)
  const maybeD3Relax = useCallback(async (nodesIn: Node[]): Promise<Node[]> => {
    try {
      const flag = (import.meta as any)?.env?.VITE_FEATURE_D3_RELAX;
      if (!flag || String(flag).toLowerCase() === 'off') return nodesIn;
      const mod = await import('./utils/d3Relax');
      return await mod.relaxLayoutWithD3(nodesIn as any, [] as any, { maxTicks: 100 });
    } catch {
      return nodesIn;
    }
  }, []);

  // --- Layout + Relaxation Orchestrator ---
  const [relaxPadding, setRelaxPadding] = useState(12);
  // Pinned nodes that should not be moved by radial base layout or relaxor
  const pinnedRef = useRef<Set<string>>(new Set());
  const reactFlowWrapperRef = useRef<HTMLDivElement | null>(null);
  const lastRadialBaseRef = useRef<Record<string, { x: number; y: number }> | null>(null);
  const clearPins = useCallback(() => {
    pinnedRef.current.clear();
  }, []);
  const recordRadialBaseline = useCallback((layoutNodes: Node[]) => {
    lastRadialBaseRef.current = buildPositionMap(layoutNodes);
  }, []);
  const hasRadialBaselineChanged = useCallback((layoutNodes: Node[]) => {
    const nextMap = buildPositionMap(layoutNodes);
    return didCanonicalPositionsChange(lastRadialBaseRef.current, nextMap);
  }, []);
  const relaxRetryRef = useRef(0);
  const relaxCooldownRef = useRef<number>(0);
  const layoutCooldownRef = useRef<number>(0);

  const waitTwoFrames = useCallback(() => new Promise<void>((resolve) => {
    requestAnimationFrame(() => requestAnimationFrame(() => resolve()));
  }), []);

  const applyLayoutAndRelax = useCallback(async (
    baseNodes: Node[],
    {
      padding = 12,
      maxPasses = 10,
      fit = true,
      fixedIds = [],
    }: { padding?: number; maxPasses?: number; fit?: boolean; fixedIds?: string[] }
  ) => {
    layoutCooldownRef.current = Date.now();
    if (!reactFlowInstance) return;

    // 1) Set base positions
    setNodes(baseNodes);
    // Ensure internals refreshed for measurement
    try {
      reactFlowInstance.updateNodeInternals(baseNodes.map(n => n.id));
    } catch {}

    // 2) Wait for React Flow to measure nodes
    await waitTwoFrames();

  // 3) Fetch fresh nodes with width/height populated
    let fresh = typeof reactFlowInstance.getNodes === 'function' ? (reactFlowInstance.getNodes() as Node[]) : baseNodes;

    // If any node still lacks size, retry once after ~16ms
    const missingSize = fresh.some(n => n.id !== 'center' && (!n.width || !n.height));
    if (missingSize) {
      // eslint-disable-next-line no-console
      console.debug('[layout] sizes not ready; retrying measurement in 16ms');
      await new Promise(r => setTimeout(r, 16));
      fresh = typeof reactFlowInstance.getNodes === 'function' ? (reactFlowInstance.getNodes() as Node[]) : baseNodes;
    }

    const dimensionSnapshot: Record<string, { width: number; height: number }> = {};
    fresh.forEach((node) => {
      const width =
        parseDimensionValue(node.width) ??
        parseDimensionValue(node.style?.width) ??
        DEFAULT_CARD_WIDTH;
      const height =
        parseDimensionValue(node.height) ??
        parseDimensionValue(node.style?.height) ??
        DEFAULT_CARD_HEIGHT;
      dimensionSnapshot[node.id] = {
        width: Math.max(1, Math.round(width)),
        height: Math.max(1, Math.round(height)),
      };
    });

    // 4) Run deterministic collision resolver using graph units (no DOM)
    // Always keep center + any pinned nodes fixed during relaxation
    const pinnedFromNodes = baseNodes.filter(n => (n as any)?.data?.pinned).map(n => n.id);
    const fixedSet = Array.from(new Set<string>(['center', ...fixedIds, ...pinnedFromNodes]));

    // Dev visibility
    if (process.env.NODE_ENV !== 'production') {
      const c0 = baseNodes.find(n => n.id === 'center')?.position;
      console.debug('[layout] fixedIds:', fixedSet, 'center@', c0);
    }

    const info = resolveCollisions(fresh as any, {
      padding,
      maxPasses,
      measure: nodeDimensionsRef.current,
      fixedIds: fixedSet,
    });
    if (info.pendingMeasurement && relaxRetryRef.current < 3) {
      relaxRetryRef.current += 1;
      // Try again on next tick
      await waitTwoFrames();
      return applyLayoutAndRelax(baseNodes, { padding, maxPasses, fit, fixedIds });
    }
    relaxRetryRef.current = 0;

    // 5) Log movement stats
    // eslint-disable-next-line no-console
    console.log(`[layout] relax moved ${info.movedCount}/${fresh.length}`);

    // 6) Apply relaxed positions and refresh
    let nextNodes = info.nodes as any;
    // Restore center position from base to guarantee it never budges
    const centerFromBase = baseNodes.find(n => n.id === 'center');
    if (centerFromBase) {
      nextNodes = nextNodes.map((n: any) => (n.id === 'center' ? { ...n, position: centerFromBase.position } : n));
    }
    nextNodes = annotateNodesWithHeightCaps(nextNodes, dimensionSnapshot) as any;
    setNodes(nextNodes);
    try {
      reactFlowInstance.updateNodeInternals(nextNodes.map((n: any) => n.id));
    } catch {}

    // 7) Fit and draw debug overlay if enabled
    if (fit) {
      try { reactFlowInstance.fitView({ padding: 0.2, duration: 300 }); } catch {}
      if (layoutDebug) requestAnimationFrame(() => devOutlineCollisions(padding));
    }

    // 8) Update edges after positions change
  setEdges((prevEdges) => updateEdgesWithOptimalHandles(nextNodes as any, prevEdges, "center"));

    // 9) Re-measure for subsequent operations
    window.requestAnimationFrame(() => refreshDimensions());
  }, [reactFlowInstance, setNodes, setEdges, layoutDebug, waitTwoFrames, relaxPadding]);

  // Relax-only pass that respects pinnedRef (and center) without recomputing base layout
  const relaxRespectingPins = useCallback(async (
    nodesIn: Node[],
    { padding = relaxPadding, maxPasses = 6 }: { padding?: number; maxPasses?: number }
  ) => {
    if (!reactFlowInstance) return;
    const now = Date.now();
    if (now - relaxCooldownRef.current < 350) {
      return;
    }
    relaxCooldownRef.current = now;

    // Apply current positions as base
    setNodes(nodesIn);
    try { reactFlowInstance.updateNodeInternals(nodesIn.map((n) => n.id)); } catch {}

    // Wait for measurement to stabilize
    await waitTwoFrames();
    let fresh = typeof reactFlowInstance.getNodes === 'function' ? (reactFlowInstance.getNodes() as Node[]) : nodesIn;

    const dimensionSnapshot: Record<string, { width: number; height: number }> = {};
    fresh.forEach((node) => {
      const width =
        parseDimensionValue(node.width) ??
        parseDimensionValue(node.style?.width) ??
        DEFAULT_CARD_WIDTH;
      const height =
        parseDimensionValue(node.height) ??
        parseDimensionValue(node.style?.height) ??
        DEFAULT_CARD_HEIGHT;
      dimensionSnapshot[node.id] = {
        width: Math.max(1, Math.round(width)),
        height: Math.max(1, Math.round(height)),
      };
    });

    // Mark pinned from ref
    const withPins = fresh.map((n) =>
      pinnedRef.current.has(n.id) ? ({ ...n, data: { ...(n.data || {}), pinned: true } } as Node) : n
    );

    if (process.env.NODE_ENV !== 'production') {
      console.debug('[layout] calling relax', { fit: false, padding, pinned: Array.from(pinnedRef.current) });
    }
    const info = resolveCollisions(withPins as any, { padding, maxPasses, measure: nodeDimensionsRef.current, fixedIds: ['center', ...Array.from(pinnedRef.current)] });

    // Ensure integer positions to avoid sub-pixel measurement jitter
    const snapped = (info.nodes as any).map((n: any) => ({ ...n, position: { x: Math.round(n.position?.x ?? 0), y: Math.round(n.position?.y ?? 0) } }))
    const annotated = annotateNodesWithHeightCaps(snapped as any, dimensionSnapshot) as any;
    setNodes(annotated);
    try { reactFlowInstance.updateNodeInternals(annotated.map((n: any) => n.id)); } catch {}
    setEdges((prevEdges) => updateEdgesWithOptimalHandles(annotated as any, prevEdges, 'center'));
    window.requestAnimationFrame(() => refreshDimensions());
  }, [reactFlowInstance, setNodes, setEdges, waitTwoFrames, relaxPadding]);

  // Safe wrapper for onNodesChange with validation
  const onNodesChange = useCallback((changes: any[]) => {
    try {
      onNodesChangeInternal(changes);
    } catch (error) {
      console.error('Error in onNodesChange:', error);
      // Silently fail to prevent crashes
    }
  }, [onNodesChangeInternal]);

  // Ensure center node is always non-draggable and non-selectable, even when nodes are loaded/restored
  useEffect(() => {
    setNodes((nds) => {
      let changed = false;
      const next = nds.map((n) => {
        if (n.id !== 'center') return n;
        const d = n as any;
        const shouldUpdate = d.draggable !== false || d.selectable !== false;
        if (shouldUpdate) {
          changed = true;
          return { ...n, draggable: false, selectable: false } as any;
        }
        return n;
      });
      return changed ? next : nds;
    });
  }, [setNodes, nodes.length]);

  // Safe wrapper for onEdgesChange with validation
  const onEdgesChange = useCallback((changes: any[]) => {
    try {
      onEdgesChangeInternal(changes);
    } catch (error) {
      console.error('Error in onEdgesChange:', error);
      // Silently fail to prevent crashes
    }
  }, [onEdgesChangeInternal]);

  function refreshDimensions() {
    if (!reactFlowInstance) return;
    const measuredNodes = typeof reactFlowInstance.getNodes === 'function'
      ? (reactFlowInstance.getNodes() as Node[])
      : [];

    if (!Array.isArray(measuredNodes) || measuredNodes.length === 0) {
      return;
    }

    const next = measureNodes(measuredNodes);

    if (Object.keys(next).length === 0) {
      return;
    }

    if (haveDimensionsChanged(nodeDimensionsRef.current, next)) {
      nodeDimensionsRef.current = next;
      setDimensionVersion((version) => version + 1);
    }
  }

  const allNodesMeasured = useMemo(() => {
    if (!nodes || nodes.length === 0) {
      return false;
    }
    return nodes.every((node) => {
      if (node.id === "center") return true;
      const entry = nodeDimensionsRef.current[node.id];
      return entry && entry.width && entry.height;
    });
  }, [nodes, dimensionVersion]);

  useEffect(() => {
    if (!nodeContextMenu.isOpen || !nodeContextMenu.nodeId) return;
    const exists = nodes.some((n) => n.id === nodeContextMenu.nodeId);
    if (!exists) {
      setNodeContextMenu({ isOpen: false, position: { x: 0, y: 0 }, nodeId: null });
    }
  }, [nodeContextMenu, nodes]);

  const activeContextNode = useMemo(() => {
    if (!nodeContextMenu.isOpen || !nodeContextMenu.nodeId) return null;
    return nodes.find((n) => n.id === nodeContextMenu.nodeId) || null;
  }, [nodeContextMenu, nodes]);

  // Undo handler
  const handleUndo = useCallback(() => {
    const previousState = historyManager.current.undo();
    if (previousState) {
      isUndoRedoAction.current = true;
      setNodes(previousState.nodes);
      setEdges(previousState.edges);
      setCanUndo(historyManager.current.canUndo());
      setCanRedo(historyManager.current.canRedo());
      toast.success("Undone", {
        description: "Canvas restored to previous state",
      });
    } else {
      toast.info("Nothing to undo");
    }
  }, [setNodes, setEdges]);

  // Redo handler
  const handleRedo = useCallback(() => {
    const nextState = historyManager.current.redo();
    if (nextState) {
      isUndoRedoAction.current = true;
      setNodes(nextState.nodes);
      setEdges(nextState.edges);
      setCanUndo(historyManager.current.canUndo());
      setCanRedo(historyManager.current.canRedo());
      toast.success("Redone", {
        description: "Canvas restored to next state",
      });
    } else {
      toast.info("Nothing to redo");
    }
  }, [setNodes, setEdges]);

  // Duplicate selected nodes
  const handleDuplicateSelected = useCallback(() => {
    const selectedNodes = nodes.filter(n => n.selected && n.id !== "center");
    if (selectedNodes.length === 0) {
      toast.info("No nodes selected");
      return;
    }

    const offset = 50;
    const newNodes = selectedNodes.map((node, index) => ({
      ...node,
      id: `${Date.now()}-${index}`,
      position: {
        x: node.position.x + offset,
        y: node.position.y + offset,
      },
      selected: false,
      data: {
        ...node.data,
        label: `${node.data.label} (Copy)`,
        isNew: true,
      },
    }));

    setNodes((nds) => [...nds, ...newNodes]);
    setIsSaved(false);
    toast.success(`Duplicated ${selectedNodes.length} node${selectedNodes.length > 1 ? 's' : ''}`, {
      description: "New copies created with offset",
    });
  }, [nodes, setNodes]);

  // Bulk operation handlers
  const handleBulkAddTags = useCallback((tags: string[]) => {
    const result = bulkAddTags(nodes, tags);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleBulkRemoveTags = useCallback((tags: string[]) => {
    const result = bulkRemoveTags(nodes, tags);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleBulkReplaceTags = useCallback((tags: string[]) => {
    const result = bulkReplaceTags(nodes, tags);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleBulkChangeType = useCallback((newType: string) => {
    const result = bulkChangeType(nodes, newType);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleBulkDelete = useCallback(() => {
    const selectedCount = nodes.filter(n => n.selected && n.id !== 'center').length;
    if (selectedCount === 0) {
      toast.info("No nodes selected");
      return;
    }

    const result = bulkDeleteNodes(nodes, edges);
    setNodes(result.nodes);
    setEdges(result.edges);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, edges, setNodes, setEdges]);

  const handleBulkCompleteAllTodos = useCallback(() => {
    const result = bulkUpdateTodos(nodes, true);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleBulkIncompleteAllTodos = useCallback(() => {
    const result = bulkUpdateTodos(nodes, false);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleBulkClearCards = useCallback(() => {
    const result = bulkClearCards(nodes);
    setNodes(result.nodes);
    setIsSaved(false);
    toast.success(result.result.message);
  }, [nodes, setNodes]);

  const handleSelectByCriteria = useCallback((criteria: BulkSelectionCriteria) => {
    const updatedNodes = selectNodesByCriteria(nodes, criteria, edges);
    setNodes(updatedNodes);
    
    const selectedCount = updatedNodes.filter(n => n.selected && n.id !== 'center').length;
    toast.success(`Selected ${selectedCount} node${selectedCount !== 1 ? 's' : ''}`);
  }, [nodes, edges, setNodes]);

  const handleDeselectAll = useCallback(() => {
    setNodes((nds) =>
      nds.map((node) => ({
        ...node,
        selected: false,
      }))
    );
  }, [setNodes]);

  // Zoom handlers
  const handleZoomIn = useCallback(() => {
    if (!reactFlowInstance) return;
    reactFlowInstance.zoomIn({ duration: 200 });
  }, [reactFlowInstance]);

  const handleZoomOut = useCallback(() => {
    if (!reactFlowInstance) return;
    reactFlowInstance.zoomOut({ duration: 200 });
  }, [reactFlowInstance]);

  const handleFitView = useCallback(() => {
    if (!reactFlowInstance) return;
    
    // Calculate dynamic max zoom based on node count
    // More nodes = allow more zoom out
    const nodeCount = nodes.length;
    let maxZoom = 1.5;
    if (nodeCount > 20) maxZoom = 2.0;
    if (nodeCount > 50) maxZoom = 2.5;
    if (nodeCount > 100) maxZoom = 3.0;
    
    reactFlowInstance.fitView({ 
      padding: 0.2, 
      duration: 400,
      maxZoom
    });
    if (layoutDebug) {
      requestAnimationFrame(() => devOutlineCollisions(12));
    }
    toast.success("Fit all nodes", {
      description: "Canvas adjusted to show all nodes",
    });
  }, [reactFlowInstance, nodes.length, layoutDebug]);

  const handleFitSelection = useCallback(() => {
    const selectedNodes = nodes.filter(n => n.selected);
    if (selectedNodes.length === 0) {
      toast.info("No nodes selected");
      return;
    }

    if (!reactFlowInstance) return;
    // Get the bounding box of selected nodes
    const nodeIds = selectedNodes.map(n => n.id);
    
    // Calculate dynamic max zoom based on selection count
    let maxZoom = 2.0;
    if (selectedNodes.length > 10) maxZoom = 2.5;
    if (selectedNodes.length > 20) maxZoom = 3.0;
    
    reactFlowInstance.fitView({
      padding: 0.3,
      duration: 400,
      maxZoom,
      nodes: selectedNodes,
    });
    if (layoutDebug) {
      requestAnimationFrame(() => devOutlineCollisions(12));
    }
    
    toast.success("Zoomed to selection", {
      description: `Focused on ${selectedNodes.length} node${selectedNodes.length > 1 ? 's' : ''}`,
    });
  }, [reactFlowInstance, nodes, layoutDebug]);

  const handleCenterCanvas = useCallback(() => {
    if (!reactFlowInstance) return;
    // Find center node and focus on it
    const centerNode = nodes.find(n => n.id === "center");
    if (centerNode) {
      const measured = nodeDimensionsRef.current?.[centerNode.id];
      const width =
        parseDimensionValue(measured?.width) ??
        parseDimensionValue(centerNode.width) ??
        parseDimensionValue(centerNode.style?.width) ??
        360;
      const height =
        parseDimensionValue(measured?.height) ??
        parseDimensionValue(centerNode.height) ??
        parseDimensionValue(centerNode.style?.height) ??
        240;
      reactFlowInstance.setCenter(
        (centerNode.position?.x ?? 0) + width / 2,
        (centerNode.position?.y ?? 0) + height / 2,
        { duration: 400, zoom: 1 }
      );
      toast.success("Centered", {
        description: "Canvas centered on main node",
      });
    }
  }, [reactFlowInstance, nodes]);

  const handleNodeFocus = useCallback((nodeId: string) => {
    if (!reactFlowInstance) return;
    const node = nodes.find(n => n.id === nodeId);
    if (node) {
      const measured = nodeDimensionsRef.current?.[node.id];
      const width =
        parseDimensionValue(measured?.width) ??
        parseDimensionValue(node.width) ??
        parseDimensionValue(node.style?.width) ??
        DEFAULT_CARD_WIDTH;
      const height =
        parseDimensionValue(measured?.height) ??
        parseDimensionValue(node.height) ??
        parseDimensionValue(node.style?.height) ??
        DEFAULT_CARD_HEIGHT;
      reactFlowInstance.setCenter(
        (node.position?.x ?? 0) + width / 2,
        (node.position?.y ?? 0) + height / 2,
        { duration: 400, zoom: 1.2 }
      );

      // Select the node
      setNodes((nds) =>
        nds.map((n) => ({
          ...n,
          selected: n.id === nodeId,
        }))
      );
      setSelectedNodeId(nodeId);
    }
  }, [reactFlowInstance, nodes, setNodes]);

  // Track zoom level changes
  useEffect(() => {
    if (!reactFlowInstance) return;
    
    const updateZoom = () => {
      if (!reactFlowInstance) return;
      const viewport = reactFlowInstance.getViewport();
      setZoomLevel(viewport.zoom);
    };

    // Update on mount
    updateZoom();

    // Listen to zoom changes
    const unsubscribe = reactFlowInstance.onMove?.(updateZoom);
    return () => {
      if (unsubscribe) unsubscribe();
    };
  }, [reactFlowInstance]);

  // Reset zoom to 100% on component mount (every reload)
  const hasResetZoom = useRef(false);
  useEffect(() => {
    if (!reactFlowInstance || hasResetZoom.current) return;
    
    hasResetZoom.current = true;
    
    // Delay to ensure ReactFlow is fully mounted and ready
    const timeoutId = setTimeout(() => {
      try {
        // Find center node
        const centerNode = nodes.find(n => n.id === "center");
        if (centerNode) {
          // Log the center node details for debugging
          console.log('Center node:', {
            position: centerNode.position,
            width: centerNode.width,
            height: centerNode.height,
            style: centerNode.style,
            styleWidthType: typeof centerNode.style?.width,
            styleHeightType: typeof centerNode.style?.height
          });
          
          // Get actual dimensions - ensure we convert strings to numbers
          let nodeWidth: number;
          if (centerNode.width) {
            nodeWidth = centerNode.width;
          } else if (centerNode.style?.width) {
            // Handle both string ("320") and number (320) cases
            const widthValue = centerNode.style.width;
            nodeWidth = typeof widthValue === 'string' ? parseInt(widthValue, 10) : widthValue;
          } else {
            nodeWidth = 320;
          }
          
          let nodeHeight: number;
          if (centerNode.height) {
            nodeHeight = centerNode.height;
          } else if (centerNode.style?.height) {
            // Handle both string and number cases
            const heightValue = centerNode.style.height;
            nodeHeight = typeof heightValue === 'string' ? parseInt(heightValue, 10) : heightValue;
          } else {
            nodeHeight = 200;
          }
          
          console.log('Parsed dimensions:', { nodeWidth, nodeHeight, nodeWidthType: typeof nodeWidth, nodeHeightType: typeof nodeHeight });
          
          // Calculate center of the node in flow coordinates
          const nodeCenterX = centerNode.position.x + nodeWidth / 2;
          const nodeCenterY = centerNode.position.y + nodeHeight / 2;
          
          console.log('Calculated center:', { 
            nodeCenterX, 
            nodeCenterY,
            nodePositionX: centerNode.position.x,
            nodePositionY: centerNode.position.y,
            calculation: `x: ${centerNode.position.x} + ${nodeWidth}/2 = ${nodeCenterX}, y: ${centerNode.position.y} + ${nodeHeight}/2 = ${nodeCenterY}`
          });
          
          // Use setCenter to properly center the node on screen
          reactFlowInstance.setCenter(nodeCenterX, nodeCenterY, { 
            zoom: 1,
            duration: 0 
          });
          
          console.log('✅ Canvas centered at 100% zoom');
        }
      } catch (err) {
        console.error('Centering error:', err);
      }
    }, 150);
    
    return () => clearTimeout(timeoutId);
  }, [reactFlowInstance, nodes]);

  useEffect(() => {
    refreshDimensions();
    const timeoutId = window.setTimeout(refreshDimensions, 120);
    return () => window.clearTimeout(timeoutId);
  }, [nodes]);

  useEffect(() => {
    const handleResize = () => refreshDimensions();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);



  // Initialize history with initial state
  useEffect(() => {
    historyManager.current.initialize({ nodes, edges });
    setCanUndo(historyManager.current.canUndo());
    setCanRedo(historyManager.current.canRedo());
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Auto-apply layout once on first load unless the user explicitly disables it
  useEffect(() => {
    if (autoLayoutOnLoadRef.current) return;
    if (!allNodesMeasured) return;
    if (isUserDragging) return;

    const storageAvailable = typeof window !== 'undefined';
    const pref = storageAvailable ? localStorage.getItem('flowforge-auto-layout-on-load') : null;
    const hasAppliedInitialLayout = storageAvailable
      ? localStorage.getItem('flowforge-initial-layout-applied') === 'true'
      : false;
    const storedLayoutVersion = storageAvailable
      ? localStorage.getItem(LAYOUT_VERSION_KEY)
      : null;
    const layoutVersionMismatch = storedLayoutVersion !== CURRENT_LAYOUT_VERSION;

    // Respect explicit opt-out via localStorage.setItem('flowforge-auto-layout-on-load', 'false')
    if (pref === 'false') return;

  const shouldAutoLayout = pref === 'true' || !hasAppliedInitialLayout || layoutVersionMismatch;
    if (!shouldAutoLayout) return;

    const t = setTimeout(() => {
      try {
        if (nodes && nodes.length > 1) {
          autoLayoutOnLoadRef.current = true;
          let layoutedNodes = applyDomainRadialLayout(nodes, {
            centerNodeId: "center",
            viewMode,
            viewportDimensions: { width: window.innerWidth, height: window.innerHeight },
            dimensions: nodeDimensionsRef.current,
          });
          // Apply layout and then perform relaxation with measurement-awareness
          if (process.env.NODE_ENV !== 'production') {
            console.debug('[layout] calling relax', { fit: true, padding: relaxPadding, pinned: Array.from(pinnedRef.current) });
          }
          setIsAutoLayouting(true);
          if (viewMode === 'radial') {
            recordRadialBaseline(layoutedNodes);
          } else {
            lastRadialBaseRef.current = null;
          }
          applyLayoutAndRelax(layoutedNodes, { padding: relaxPadding, maxPasses: 10, fit: true, fixedIds: ['center', ...Array.from(pinnedRef.current)] }).then(() => {
            if (storageAvailable) {
              localStorage.setItem('flowforge-initial-layout-applied', 'true');
              localStorage.setItem(LAYOUT_VERSION_KEY, CURRENT_LAYOUT_VERSION);
            }
          }).finally(() => {
            setTimeout(() => setIsAutoLayouting(false), 600);
          });
        }
      } catch (e) {
        console.warn('Auto-layout on load failed:', e);
      }
    }, 250);

    return () => clearTimeout(t);
  }, [allNodesMeasured, nodes, viewMode, applyLayoutAndRelax, relaxPadding, isUserDragging, recordRadialBaseline]);

  // Keep radial layout spacing in sync with live node dimensions
  // Debounced dimension watcher for radial view: throttle via requestAnimationFrame
  useEffect(() => {
    if (viewMode !== "radial") return;
    if (!allNodesMeasured) return;
    if (!nodeDimensionsRef.current || Object.keys(nodeDimensionsRef.current).length === 0) return;
    if (isUserDragging) return;
    if (isAutoLayouting) return;
    if (Date.now() - layoutCooldownRef.current < 450) return;

    let rafId = 0;
    rafId = requestAnimationFrame(() => {
      // If there are pinned nodes, skip full recompute and only relax respecting pins
      if (pinnedRef.current.size > 0) {
        const current = typeof reactFlowInstance?.getNodes === 'function'
          ? (reactFlowInstance!.getNodes() as Node[])
          : nodes;
        relaxRespectingPins(current, { padding: relaxPadding, maxPasses: 4 });
        return;
      }

      const layoutedNodes = applyDomainRadialLayout(nodes, {
        centerNodeId: "center",
        viewMode: "radial",
        viewportDimensions: { width: window.innerWidth, height: window.innerHeight },
        dimensions: nodeDimensionsRef.current,
        pinnedIds: pinnedRef.current,
      });

      if (!hasRadialBaselineChanged(layoutedNodes)) {
        return;
      }

      recordRadialBaseline(layoutedNodes);
      setIsAutoLayouting(true);
      if (process.env.NODE_ENV !== 'production') {
        console.debug('[layout] calling relax', { fit: false, padding: relaxPadding, pinned: Array.from(pinnedRef.current) });
      }
      applyLayoutAndRelax(layoutedNodes, { padding: relaxPadding, maxPasses: 10, fit: false, fixedIds: ['center', ...Array.from(pinnedRef.current)] }).finally(() => {
        setTimeout(() => setIsAutoLayouting(false), 480);
      });
    });
    return () => cancelAnimationFrame(rafId);
  }, [dimensionVersion, viewMode, allNodesMeasured, nodes, applyLayoutAndRelax, relaxPadding, isUserDragging, isAutoLayouting, reactFlowInstance, relaxRespectingPins, hasRadialBaselineChanged, recordRadialBaseline]);

  // Track changes to nodes/edges for history (with debounce to avoid tracking every drag)
  useEffect(() => {
    // Skip if this change was caused by undo/redo
    if (isUndoRedoAction.current) {
      isUndoRedoAction.current = false;
      return;
    }

    // Debounce to avoid saving too frequently (e.g., during drag)
    const timeoutId = setTimeout(() => {
      historyManager.current.push({ nodes, edges });
      setCanUndo(historyManager.current.canUndo());
      setCanRedo(historyManager.current.canRedo());
    }, 500);

    return () => clearTimeout(timeoutId);
  }, [nodes, edges]);

  // Check for first visit and show onboarding
  useEffect(() => {
    const hasSeenOnboarding = localStorage.getItem("flowforge-onboarding-seen");
    // Show onboarding on first visit with minimal nodes (center node only or one additional)
    if (!hasSeenOnboarding && nodes.length <= 1) {
      setShowOnboarding(true);
    }
    
    // Show empty state if only center node exists
    if (nodes.length <= 1 && hasSeenOnboarding) {
      setShowEmptyState(true);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Update empty state when nodes change
  useEffect(() => {
    const hasSeenOnboarding = localStorage.getItem("flowforge-onboarding-seen");
    // Only show empty state when there's truly just the center node (or nothing)
    setShowEmptyState(nodes.length <= 1 && hasSeenOnboarding === "true");
    if (nodes.length > 1) {
      initialCenterFitRef.current = false;
    }
  }, [nodes.length]);

  const hasSingleCenterNode = nodes.length === 1 && nodes[0]?.id === 'center';

  const centerViewportOnCenterNode = useCallback(() => {
    if (!reactFlowInstance) return;
    const wrapper = reactFlowWrapperRef.current;
    if (!wrapper) return;
    const centerNode = nodes.find((n) => n.id === 'center');
    if (!centerNode) return;

    const { clientWidth, clientHeight } = wrapper;
    if (!clientWidth || !clientHeight) return;

    const measured = nodeDimensionsRef.current?.[centerNode.id];
    const width =
      parseDimensionValue(measured?.width) ??
      parseDimensionValue(centerNode.style?.width) ??
      parseDimensionValue((centerNode as any).width) ??
      360;
    const height =
      parseDimensionValue(measured?.height) ??
      parseDimensionValue(centerNode.style?.height) ??
      parseDimensionValue((centerNode as any).height) ??
      240;

    const posX = centerNode.position?.x ?? 0;
    const posY = centerNode.position?.y ?? 0;

    const targetX = clientWidth / 2 - (posX + width / 2);
    const targetY = clientHeight / 2 - (posY + height / 2);

    try {
      reactFlowInstance.setViewport({ x: targetX, y: targetY, zoom: 1 }, { duration: 0 });
      initialCenterFitRef.current = true;
    } catch {}
  }, [reactFlowInstance, nodes]);

  useEffect(() => {
    if (!reactFlowInstance) return;
    if (hasSingleCenterNode && !initialCenterFitRef.current) {
      requestAnimationFrame(() => centerViewportOnCenterNode());
    }
  }, [hasSingleCenterNode, reactFlowInstance, centerViewportOnCenterNode, dimensionVersion, showEmptyState]);

  useEffect(() => {
    if (!hasSingleCenterNode) return;
    const handleResize = () => {
      initialCenterFitRef.current = false;
      requestAnimationFrame(() => centerViewportOnCenterNode());
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [hasSingleCenterNode, centerViewportOnCenterNode]);

  // Keyboard shortcuts for multi-select and actions
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const cmdOrCtrl = isMac ? event.metaKey : event.ctrlKey;

      // Undo (Cmd/Ctrl + Z)
      if (cmdOrCtrl && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        handleUndo();
      }

      // Redo (Cmd/Ctrl + Shift + Z or Cmd/Ctrl + Y)
      if ((cmdOrCtrl && event.shiftKey && event.key === 'z') || (cmdOrCtrl && event.key === 'y')) {
        event.preventDefault();
        handleRedo();
      }

      // Fit View (Cmd/Ctrl + 0)
      if (cmdOrCtrl && event.key === '0') {
        event.preventDefault();
        handleFitView();
      }

      // Zoom to Selection (Cmd/Ctrl + Shift + 0 or F)
      if ((cmdOrCtrl && event.shiftKey && event.key === '0') || event.key === 'f') {
        const hasSelection = nodes.some(n => n.selected);
        if (hasSelection) {
          event.preventDefault();
          handleFitSelection();
        }
      }

      // Center Canvas (Cmd/Ctrl + .)
      if (cmdOrCtrl && event.key === '.') {
        event.preventDefault();
        handleCenterCanvas();
      }

      // Command Palette (Cmd/Ctrl + K)
      if (cmdOrCtrl && event.key === 'k') {
        event.preventDefault();
        setIsCommandPaletteOpen(true);
      }

      // Keyboard Shortcuts (?)
      if (event.key === '?' && !event.metaKey && !event.ctrlKey) {
        event.preventDefault();
        setIsKeyboardShortcutsOpen(true);
      }

      // Select All (Cmd/Ctrl + A)
      if (cmdOrCtrl && event.key === 'a') {
        event.preventDefault();
        setNodes((nds) =>
          nds.map((node) => ({
            ...node,
            selected: true,
          }))
        );
        toast.success("All nodes selected");
      }

      // Deselect All (Escape)
      if (event.key === 'Escape') {
        setNodes((nds) =>
          nds.map((node) => ({
            ...node,
            selected: false,
          }))
        );
      }

      // Duplicate Selected (Cmd/Ctrl + D)
      if (cmdOrCtrl && event.key === 'd') {
        event.preventDefault();
        handleDuplicateSelected();
      }

      // Select by Criteria (Cmd/Ctrl + Shift + F)
      if (cmdOrCtrl && event.shiftKey && event.key.toLowerCase() === 'f') {
        event.preventDefault();
        setIsSelectByCriteriaOpen(true);
      }

      // Delete Selected (Delete/Backspace)
      if ((event.key === 'Delete' || event.key === 'Backspace') && !event.metaKey && !event.ctrlKey) {
        const selectedNodeCount = nodes.filter(n => n.selected && n.id !== 'center').length;
        const selectedEdgeIds = edges.filter(e => e.selected).map(e => e.id);

        // If nodes are selected, handle via our bulk delete (prevents deleting the center)
        if (selectedNodeCount > 0) {
          event.preventDefault();
          handleBulkDelete();
          return;
        }

        // If only edges are selected:
        if (selectedEdgeIds.length > 0) {
          if (event.key === 'Backspace') {
            // Support Backspace on macOS where Delete key often maps to Backspace
            event.preventDefault();
            setEdges(eds => eds.filter(e => !selectedEdgeIds.includes(e.id)));
            toast.success(`Deleted ${selectedEdgeIds.length} connection${selectedEdgeIds.length > 1 ? 's' : ''}`);
            return;
          }
          // For the actual Delete key, let React Flow handle it (don't preventDefault)
        }
      }

    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [setNodes, handleUndo, handleRedo, handleFitView, handleFitSelection, handleCenterCanvas, nodes, setIsKeyboardShortcutsOpen, setIsCommandPaletteOpen, handleDuplicateSelected, handleBulkDelete]);
  

  // Update edges with optimal handles whenever nodes change
  useEffect(() => {
    // Skip if currently editing text or placing a node to avoid interference
    if (isEditingText || isPlacingNode) {
      return;
    }
    
    try {
      const updatedEdges = updateEdgesWithOptimalHandles(nodes, edges, "center");
      // Only update if edges actually changed to avoid infinite loop
      const edgesChanged = updatedEdges.some((edge, i) => {
        const originalEdge = edges[i];
        return (
          edge.sourceHandle !== originalEdge?.sourceHandle ||
          edge.targetHandle !== originalEdge?.targetHandle
        );
      });
      
      if (edgesChanged) {
        setEdges(updatedEdges);
      }
    } catch (error) {
      console.error('Error updating edges with optimal handles:', error);
    }
  }, [nodes, isEditingText, isPlacingNode]); // Only depend on nodes and editing state, not edges

  const onConnect = useCallback(
    (params: Edge | Connection) => {
      // Normalize handle ids to our side-suffixed scheme and ensure source uses -source and target uses -target
      const normalizeHandle = (h: string | null | undefined, desired: 'source' | 'target') => {
        if (!h) return h;
        const m = String(h).match(/^(top|right|bottom|left)(?:-(?:source|target))?$/);
        if (m) return `${m[1]}-${desired}`;
        return h;
      };
      const normalized = {
        ...params,
        sourceHandle: normalizeHandle((params as any).sourceHandle, 'source'),
        targetHandle: normalizeHandle((params as any).targetHandle, 'target'),
      } as Edge | Connection;
      const newEdge = { ...normalized, type: "custom" };
      setEdges((eds) => {
        const updatedEdges = addEdge(newEdge, eds);
        return updateEdgesWithOptimalHandles(nodes, updatedEdges, "center");
      });
      setIsSaved(false);
      didConnectRef.current = true;
      setIsConnecting(false);
    },
    [setEdges, nodes]
  );

  const onConnectStart = useCallback((event: any, params: any) => {
    setIsConnecting(true);
    didConnectRef.current = false;
    connectStartInfoRef.current = { nodeId: params?.nodeId ?? null, handleId: params?.handleId ?? null };
    setConnectStart(connectStartInfoRef.current);
  }, []);

  const onConnectEnd = useCallback((event: any) => {
    setIsConnecting(false);
    setConnectStart(null);
    // If no valid connection was made, interpret as "create new node" drop
    if (!didConnectRef.current && connectStartInfoRef.current?.nodeId && reactFlowInstance) {
      const { clientX, clientY } = event as MouseEvent;
      const pos = reactFlowInstance.screenToFlowPosition({ x: clientX, y: clientY });
      // Open Add Node modal at drop position, pre-linking source node
      setEdgePosition(pos);
      setNodeTypeToAdd(undefined);
      setDragSourceNodeId(connectStartInfoRef.current.nodeId);
      setIsAddNodeModalOpen(true);
    }
    // Reset flags
    didConnectRef.current = false;
    connectStartInfoRef.current = null;
  }, [reactFlowInstance]);

  const handleExpandCard = useCallback((nodeId: string, cardId: string) => {
    const node = nodes.find(n => n.id === nodeId);
    const card = node?.data.cards?.find((c: EditableCardData) => c.id === cardId);
    if (card) {
      setSelectedCard({ nodeId, card });
      setIsDetailPanelOpen(true);
    }
  }, [nodes]);

  const handleUpdateCardInPanel = useCallback((updatedCard: EditableCardData) => {
    if (!selectedCard) return;
    
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === selectedCard.nodeId) {
          const updatedCards = node.data.cards?.map((c: EditableCardData) =>
            c.id === updatedCard.id ? updatedCard : c
          );
          return {
            ...node,
            data: {
              ...node.data,
              cards: updatedCards,
            },
          };
        }
        return node;
      })
    );
    setSelectedCard({ ...selectedCard, card: updatedCard });
    setIsSaved(false);
  }, [selectedCard, setNodes]);

  const handleAddCard = useCallback((nodeId: string, type: "text" | "todo") => {
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === nodeId) {
          const newCard: EditableCardData = {
            id: `c${Date.now()}`,
            title: type === "text" ? "New Text Card" : "New To-Do List",
            type,
            content: type === "text" ? "" : undefined,
            todos: type === "todo" ? [] : undefined,
          };
          return {
            ...node,
            data: {
              ...node.data,
              cards: [...(node.data.cards || []), newCard],
            },
          };
        }
        return node;
      })
    );
    setIsSaved(false);
    toast.success("Card added");
  }, [setNodes]);

  const handleUpdateCard = useCallback((nodeId: string, cardId: string, updatedCard: EditableCardData) => {
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === nodeId) {
          const updatedCards = node.data.cards?.map((c: EditableCardData) =>
            c.id === cardId ? updatedCard : c
          );
          return {
            ...node,
            data: {
              ...node.data,
              cards: updatedCards,
            },
          };
        }
        return node;
      })
    );
    setIsSaved(false);
  }, [setNodes]);

  const handleDeleteCard = useCallback((nodeId: string, cardId: string) => {
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === nodeId) {
          const updatedCards = node.data.cards?.filter((c: EditableCardData) => c.id !== cardId);
          return {
            ...node,
            data: {
              ...node.data,
              cards: updatedCards,
            },
          };
        }
        return node;
      })
    );
    setIsSaved(false);
    toast.success("Card deleted");
  }, [setNodes]);

  // Center node update handler
  const handleUpdateCenterNode = useCallback((updates: Partial<CenterNodeData>) => {
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === "center") {
          return {
            ...node,
            data: {
              ...node.data,
              ...updates,
            },
          };
        }
        return node;
      })
    );
    setIsSaved(false);
    toast.success("Center node updated");
  }, [setNodes]);

  // AI Enrichment handlers
  const handleOpenEnrichment = useCallback((nodeId: string) => {
    
```
## Collision Utils: `client/src/utils/collision.ts`
```tsx
// @ts-nocheck
import type { Node as RFNode } from '@xyflow/react'

export type Rect = { id: string; x: number; y: number; w: number; h: number }
export type OverlapPair = { a: string; b: string }

const DEFAULT_NODE_WIDTH = 280
const DEFAULT_NODE_HEIGHT = 200
const DEFAULT_CENTER_DIMENSIONS = { width: 360, height: 240 }

function parseDimension(value: unknown): number | undefined {
  if (typeof value === 'number' && Number.isFinite(value)) return value
  if (typeof value === 'string') {
    const n = parseFloat(value)
    if (Number.isFinite(n)) return n
  }
  return undefined
}

function getFallbackDims(node: RFNode): { width: number; height: number } {
  if (node?.type === 'center') return DEFAULT_CENTER_DIMENSIONS
  return { width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT }
}

function getDims(node: RFNode, measure?: Record<string, { width: number; height: number }>): { width: number; height: number } {
  const cached = measure?.[node.id]
  const fallback = getFallbackDims(node)
  const width = parseDimension(cached?.width) ?? parseDimension((node as any).width) ?? parseDimension((node as any).style?.width) ?? fallback.width
  const height = parseDimension(cached?.height) ?? parseDimension((node as any).height) ?? parseDimension((node as any).style?.height) ?? fallback.height
  return { width: Math.max(1, Math.round(width)), height: Math.max(1, Math.round(height)) }
}

function isFixedNode(n: RFNode | undefined | null): boolean {
  if (!n) return false
  // Treat center and pinned nodes as fixed (immovable) during relaxation
  // Center can be identified by id or type
  const isCenter = n.id === 'center' || (n as any).type === 'center'
  const isPinned = Boolean((n as any)?.data?.pinned === true)
  return isCenter || isPinned
}

export function rectsFromNodes(nodes: RFNode[], measure?: Record<string, { width: number; height: number }>): Rect[] {
  return nodes.map((n) => {
    const { width, height } = getDims(n, measure)
    return { id: n.id, x: n.position?.x ?? 0, y: n.position?.y ?? 0, w: width, h: height }
  })
}

function aabbOverlap(a: Rect, b: Rect, padding: number): boolean {
  return (
    a.x < b.x + b.w + padding &&
    a.x + a.w + padding > b.x &&
    a.y < b.y + b.h + padding &&
    a.y + a.h + padding > b.y
  )
}

export function findOverlaps(rects: Rect[], padding: number = 12): OverlapPair[] {
  const overlaps: OverlapPair[] = []
  for (let i = 0; i < rects.length; i++) {
    for (let j = i + 1; j < rects.length; j++) {
      if (aabbOverlap(rects[i], rects[j], padding)) {
        overlaps.push({ a: rects[i].id, b: rects[j].id })
      }
    }
  }
  return overlaps
}

export function resolveCollisions(
  nodes: RFNode[],
  opts?: { padding?: number; maxPasses?: number; measure?: Record<string, { width: number; height: number }>; fixedIds?: string[] }
): { nodes: RFNode[]; pendingMeasurement: boolean; movedCount: number; totalDelta: number } {
  const padding = opts?.padding ?? 12
  const maxPasses = Math.max(1, opts?.maxPasses ?? 10)
  const measure = opts?.measure
  const fixedSet = new Set<string>(opts?.fixedIds ?? [])

  // Work on a copy to avoid mutating callers unexpectedly
  const idToIndex = new Map(nodes.map((n, i) => [n.id, i]))
  const original: RFNode[] = nodes.map((n) => ({ ...n }))
  const out: RFNode[] = nodes.map((n) => ({ ...n, position: { ...(n.position ?? { x: 0, y: 0 }) } }))

  // Ensure we have measured width/height (graph units) for all nodes except fixed center
  const missingDims = out.some((n) => {
    if (n.id === 'center' || n.type === 'center') return false
    const w = (n as any).width
    const h = (n as any).height
    const hasMeasured = typeof w === 'number' && w > 0 && typeof h === 'number' && h > 0
    if (hasMeasured) return false
    // Allow explicit measure override passed in opts
    const m = measure?.[n.id]
    if (m && typeof m.width === 'number' && typeof m.height === 'number') return false
    return true
  })
  if (missingDims) {
    return { nodes, pendingMeasurement: true, movedCount: 0, totalDelta: 0 }
  }

  // Helper to compute rect for a node id
  const rectFor = (id: string): Rect => {
    const idx = idToIndex.get(id)!
    const node = out[idx]
    const { width, height } = getDims(node, measure)
    return { id, x: node.position.x, y: node.position.y, w: width, h: height }
  }

  // Pre-pass: clear collisions with fixed center by pushing others directly away from it
  const fixedCenter = out.find((n) => n.id === 'center' || n.type === 'center')
  if (fixedCenter) {
    const centerRect = rectFor(fixedCenter.id)
    for (const n of out) {
      if (n.id === fixedCenter.id) continue
      // Do not move pinned nodes in the pre-pass either
      if (isFixedNode(n) || fixedSet.has(n.id)) continue
      const r = rectFor(n.id)
      if (!aabbOverlap(centerRect, r, padding)) continue

      const overlapX1 = centerRect.x + centerRect.w + padding - r.x
      const overlapX2 = r.x + r.w + padding - centerRect.x
      const pushX = Math.min(overlapX1, overlapX2)

      const overlapY1 = centerRect.y + centerRect.h + padding - r.y
      const overlapY2 = r.y + r.h + padding - centerRect.y
      const pushY = Math.min(overlapY1, overlapY2)

      const moveAlongX = pushX <= pushY
      const minimalPush = Math.max(1, Math.round(moveAlongX ? pushX : pushY))

      const idx = idToIndex.get(n.id)!
      if (moveAlongX) {
        // Push away from center along X
        if (r.x >= centerRect.x) out[idx].position.x += minimalPush
        else out[idx].position.x -= minimalPush
      } else {
        // Push away from center along Y
        if (r.y >= centerRect.y) out[idx].position.y += minimalPush
        else out[idx].position.y -= minimalPush
      }
    }
  }

  for (let pass = 0; pass < maxPasses; pass++) {
    const rects = rectsFromNodes(out, measure)
    const pairs = findOverlaps(rects, padding)
    if (pairs.length === 0) break

    // Ensure deterministic ordering of resolution
    pairs.sort((p1, p2) => (p1.a + '|' + p1.b).localeCompare(p2.a + '|' + p2.b))

    let movedThisPass = 0

    for (const pair of pairs) {
      const aRect = rectFor(pair.a)
      const bRect = rectFor(pair.b)

      // Re-check overlap as nodes may have moved this pass
      if (!aabbOverlap(aRect, bRect, padding)) continue

      // Compute minimal push distance along x or y
      const overlapX1 = aRect.x + aRect.w + padding - bRect.x
      const overlapX2 = bRect.x + bRect.w + padding - aRect.x
      const pushX = Math.min(overlapX1, overlapX2)

      const overlapY1 = aRect.y + aRect.h + padding - bRect.y
      const overlapY2 = bRect.y + bRect.h + padding - aRect.y
      const pushY = Math.min(overlapY1, overlapY2)

  const moveAlongX = pushX <= pushY
  const minimalPush = Math.max(1, Math.round(moveAlongX ? pushX : pushY))
  const halfPush = Math.max(1, Math.round(minimalPush / 2))

      const idxA = idToIndex.get(pair.a)!
      const idxB = idToIndex.get(pair.b)!
      const nodeA = out[idxA]
      const nodeB = out[idxB]

  const aIsFixed = isFixedNode(nodeA) || fixedSet.has(nodeA.id)
  const bIsFixed = isFixedNode(nodeB) || fixedSet.has(nodeB.id)

      if (moveAlongX) {
        // Decide push directions deterministically using id ordering
        const leftId = aRect.x <= bRect.x ? nodeA.id : nodeB.id
        const rightId = leftId === nodeA.id ? nodeB.id : nodeA.id

        // If one is fixed, push the other the full minimal distance to clear overlap in one step
        const pushAmountLeft = (aIsFixed && nodeA.id === leftId) || (bIsFixed && nodeB.id === leftId) ? minimalPush : halfPush
        const pushAmountRight = (aIsFixed && nodeA.id === rightId) || (bIsFixed && nodeB.id === rightId) ? minimalPush : halfPush

        if (!aIsFixed && nodeA.id === leftId) out[idxA].position.x -= pushAmountLeft
        if (!bIsFixed && nodeB.id === leftId) out[idxB].position.x -= pushAmountLeft
        if (!aIsFixed && nodeA.id === rightId) out[idxA].position.x += pushAmountRight
        if (!bIsFixed && nodeB.id === rightId) out[idxB].position.x += pushAmountRight
      } else {
        const topId = aRect.y <= bRect.y ? nodeA.id : nodeB.id
        const bottomId = topId === nodeA.id ? nodeB.id : nodeA.id

        const pushAmountTop = (aIsFixed && nodeA.id === topId) || (bIsFixed && nodeB.id === topId) ? minimalPush : halfPush
        const pushAmountBottom = (aIsFixed && nodeA.id === bottomId) || (bIsFixed && nodeB.id === bottomId) ? minimalPush : halfPush

        if (!aIsFixed && nodeA.id === topId) out[idxA].position.y -= pushAmountTop
        if (!bIsFixed && nodeB.id === topId) out[idxB].position.y -= pushAmountTop
        if (!aIsFixed && nodeA.id === bottomId) out[idxA].position.y += pushAmountBottom
        if (!bIsFixed && nodeB.id === bottomId) out[idxB].position.y += pushAmountBottom
      }

      movedThisPass++
    }

    if (movedThisPass === 0) break
  }

  // Last-chance greedy sweep if overlaps remain after allotted passes
  {
    const rects = rectsFromNodes(out, measure)
    const pairs = findOverlaps(rects, padding)
    if (pairs.length > 0) {
      // Deterministic order
      pairs.sort((p1, p2) => (p1.a + '|' + p1.b).localeCompare(p2.a + '|' + p2.b))
      for (const pair of pairs) {
        const idxA = idToIndex.get(pair.a)!
        const idxB = idToIndex.get(pair.b)!
        const nA = out[idxA]
        const nB = out[idxB]
  const aIsFixed = isFixedNode(nA) || fixedSet.has(nA.id)
  const bIsFixed = isFixedNode(nB) || fixedSet.has(nB.id)
        const aRect = rectFor(pair.a)
        const bRect = rectFor(pair.b)
        if (!aabbOverlap(aRect, bRect, padding)) continue
        const overlapX1 = aRect.x + aRect.w + padding - bRect.x
        const overlapX2 = bRect.x + bRect.w + padding - aRect.x
        const pushX = Math.min(overlapX1, overlapX2)
        const overlapY1 = aRect.y + aRect.h + padding - bRect.y
        const overlapY2 = bRect.y + bRect.h + padding - aRect.y
        const pushY = Math.min(overlapY1, overlapY2)
        const moveAlongX = pushX <= pushY
        const minimalPush = Math.max(1, Math.round(moveAlongX ? pushX : pushY))

        if (moveAlongX) {
          if (!aIsFixed && aRect.x <= bRect.x) out[idxA].position.x -= minimalPush
          if (!bIsFixed && bRect.x <= aRect.x) out[idxB].position.x -= minimalPush
          if (!aIsFixed && aRect.x > bRect.x) out[idxA].position.x += minimalPush
          if (!bIsFixed && bRect.x > aRect.x) out[idxB].position.x += minimalPush
        } else {
          if (!aIsFixed && aRect.y <= bRect.y) out[idxA].position.y -= minimalPush
          if (!bIsFixed && bRect.y <= aRect.y) out[idxB].position.y -= minimalPush
          if (!aIsFixed && aRect.y > bRect.y) out[idxA].position.y += minimalPush
          if (!bIsFixed && bRect.y > aRect.y) out[idxB].position.y += minimalPush
        }
      }
    }
  }

  // Final targeted sweep: if any node still overlaps the fixed center, push it directly away
  {
    const center = out.find((n) => n.id === 'center' || n.type === 'center')
    if (center) {
      const cRect = rectFor(center.id)
      for (const n of out) {
        if (n.id === center.id) continue
        // Do not move pinned nodes in the final sweep
  if (isFixedNode(n) || fixedSet.has(n.id)) continue
        const r = rectFor(n.id)
        if (!aabbOverlap(cRect, r, padding)) continue
        const overlapX1 = cRect.x + cRect.w + padding - r.x
        const overlapX2 = r.x + r.w + padding - cRect.x
        const pushX = Math.min(overlapX1, overlapX2)
        const overlapY1 = cRect.y + cRect.h + padding - r.y
        const overlapY2 = r.y + r.h + padding - cRect.y
        const pushY = Math.min(overlapY1, overlapY2)
        const moveAlongX = pushX <= pushY
        const minimalPush = Math.max(1, Math.round(moveAlongX ? pushX : pushY))
        const idx = idToIndex.get(n.id)!
        if (moveAlongX) {
          if (r.x >= cRect.x) out[idx].position.x += minimalPush
          else out[idx].position.x -= minimalPush
        } else {
          if (r.y >= cRect.y) out[idx].position.y += minimalPush
          else out[idx].position.y -= minimalPush
        }
      }
    }
  }

  // Metrics
  let movedCount = 0
  let totalDelta = 0
  for (let i = 0; i < out.length; i++) {
    const before = original[i]
    const after = out[i]
    if (!before?.position || !after?.position) continue
    const dx = Math.round(after.position.x - before.position.x)
    const dy = Math.round(after.position.y - before.position.y)
    if (dx !== 0 || dy !== 0) movedCount++
    totalDelta += Math.abs(dx) + Math.abs(dy)
  }

  // Optional: if still overlapping, log for diagnostics (test env captures console)
  try {
    const remaining = findOverlaps(rectsFromNodes(out, measure), padding)
    if (remaining.length > 0) {
      // eslint-disable-next-line no-console
      console.warn(`[collision] Remaining overlaps after relax: ${remaining.length} pairs ->`, remaining.slice(0, 8))
    }
  } catch {}

  // Snap final positions to integer pixels to reduce visual jitter
  const snapped = out.map((n) => ({
    ...n,
    position: { x: Math.round(n.position?.x ?? 0), y: Math.round(n.position?.y ?? 0) },
  }))
  return { nodes: snapped, pendingMeasurement: false, movedCount, totalDelta }
}

// Thin wrapper to match requested API name in domainLayout
export function relaxCollisions(nodes: RFNode[], opts?: { padding?: number; maxPasses?: number; measure?: Record<string, { width: number; height: number }> }): { nodes: RFNode[]; pendingMeasurement: boolean; movedCount: number; totalDelta: number } {
  return resolveCollisions(nodes, opts)
}

// DEV overlay: outline nodes that currently overlap in the DOM
export function devOutlineCollisions(padding: number = 12): void {
  try {
    const root = document?.querySelector?.('.react-flow') as HTMLElement | null
    if (!root) return

    // Clear previous outlines
    root.querySelectorAll('.react-flow__node').forEach((el) => {
      ;(el as HTMLElement).style.outline = 'none'
      ;(el as HTMLElement).style.boxShadow = 'none'
    })

    const entries = Array.from(root.querySelectorAll('.react-flow__node')) as HTMLElement[]
    const rects: { id: string; el: HTMLElement; rect: DOMRect }[] = entries.map((el) => ({
      id: el.getAttribute('data-id') || '',
      el,
      rect: el.getBoundingClientRect(),
    }))

    const offenders = new Set<string>()
    for (let i = 0; i < rects.length; i++) {
      for (let j = i + 1; j < rects.length; j++) {
        const a = rects[i].rect
        const b = rects[j].rect
        const overlaps = a.left < b.right + padding && a.right + padding > b.left && a.top < b.bottom + padding && a.bottom + padding > b.top
        if (overlaps) {
          rects[i].el.style.outline = '2px solid #ef4444'
          rects[j].el.style.outline = '2px solid #ef4444'
          rects[i].el.style.boxShadow = '0 0 0 2px rgba(239,68,68,0.35) inset'
          rects[j].el.style.boxShadow = '0 0 0 2px rgba(239,68,68,0.35) inset'
          offenders.add(rects[i].id)
          offenders.add(rects[j].id)
        }
      }
    }

    if (offenders.size > 0) {
      // eslint-disable-next-line no-console
      console.warn(`[layout] Overlaps detected: ${Array.from(offenders).join(', ')}`)
    }
  } catch (e) {
    // Ignore in environments without DOM
  }
}

```
